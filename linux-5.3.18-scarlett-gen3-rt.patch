diff -uNr linux-5.3.18-custom-rt-orig/sound/usb/mixer.c linux-5.3.18-custom-rt/sound/usb/mixer.c
--- linux-5.3.18-custom-rt-orig/sound/usb/mixer.c	2020-10-04 12:17:41.113670329 +0300
+++ linux-5.3.18-custom-rt/sound/usb/mixer.c	2020-10-04 13:52:15.068810987 +0300
@@ -50,7 +50,7 @@
 #include "mixer_quirks.h"
 #include "power.h"
 
-#define MAX_ID_ELEMS	256
+#define MAX_ID_ELEMS	512
 
 struct usb_audio_term {
 	int id;
diff -uNr linux-5.3.18-custom-rt-orig/sound/usb/mixer_quirks.c linux-5.3.18-custom-rt/sound/usb/mixer_quirks.c
--- linux-5.3.18-custom-rt-orig/sound/usb/mixer_quirks.c	2020-10-04 12:17:41.113670329 +0300
+++ linux-5.3.18-custom-rt/sound/usb/mixer_quirks.c	2020-10-04 13:51:47.145996149 +0300
@@ -2267,6 +2267,10 @@
 	case USB_ID(0x1235, 0x8203): /* Focusrite Scarlett 6i6 2nd Gen */
 	case USB_ID(0x1235, 0x8204): /* Focusrite Scarlett 18i8 2nd Gen */
 	case USB_ID(0x1235, 0x8201): /* Focusrite Scarlett 18i20 2nd Gen */
+	case USB_ID(0x1235, 0x8212): /* Focusrite Scarlett 4i4 3rd Gen */
+	case USB_ID(0x1235, 0x8213): /* Focusrite Scarlett 8i6 3rd Gen */
+	case USB_ID(0x1235, 0x8214): /* Focusrite Scarlett 18i8 3rd Gen */
+	case USB_ID(0x1235, 0x8215): /* Focusrite Scarlett 18i20 3rd Gen */
 		err = snd_scarlett_gen2_controls_create(mixer);
 		break;
 
diff -uNr linux-5.3.18-custom-rt-orig/sound/usb/mixer_scarlett_gen2.c linux-5.3.18-custom-rt/sound/usb/mixer_scarlett_gen2.c
--- linux-5.3.18-custom-rt-orig/sound/usb/mixer_scarlett_gen2.c	2020-10-04 12:17:41.115670325 +0300
+++ linux-5.3.18-custom-rt/sound/usb/mixer_scarlett_gen2.c	2020-10-06 01:59:20.425998963 +0300
@@ -1,8 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *   Focusrite Scarlett 6i6/18i8/18i20 Gen 2 Driver for ALSA
+ *   Focusrite Scarlett 6i6/18i8/18i20 Gen 2 and 4i4/8i6/18i8/18i20
+ *   Gen 3 Driver for ALSA
  *
- *   Copyright (c) 2018-2019 by Geoffrey D. Bennett <g at b4.vu>
+ *   Copyright (c) 2018-2020 by Geoffrey D. Bennett <g at b4.vu>
+ *   Copyright (c) 2018-2020 by Vladimir Sadovnikov <sadko4u at gmail.com>
  *
  *   Based on the Scarlett (Gen 1) Driver for ALSA:
  *
@@ -19,25 +21,36 @@
  *   David Henningsson <david.henningsson at canonical.com>
  */
 
-/* Mixer Interface for the Focusrite Scarlett 6i6/18i8/18i20 Gen 2 audio
- * interface. Based on the Gen 1 driver and rewritten.
+/* Mixer Interface for the Focusrite Scarlett 6i6/18i8/18i20 Gen 2 and
+ * 4i4/8i6/18i8/18i20 Gen 3 audio interfaces. Based on the Gen 1
+ * driver and rewritten.
  */
 
 /* The protocol was reverse engineered by looking at the communication
  * between Focusrite Control 2.3.4 and the Focusrite(R) Scarlett 18i20
  * (firmware 1083) using usbmon in July-August 2018.
  *
- * Scarlett 18i8 support added in April 2019.
+ * Scarlett 18i8 Gen 2 support added in April 2019.
  *
- * Scarlett 6i6 support added in June 2019 (thanks to Martin Wittmann
- * for providing usbmon output and testing).
+ * Scarlett 6i6 Gen 2 support added in June 2019 (thanks to Martin
+ * Wittmann for providing usbmon output and testing).
  *
- * This ALSA mixer gives access to:
+ * Scarlett 4i4/8i6 Gen 3 support added in May 2020 (thanks to Laurent
+ * Debricon for donating a 4i4 and to Fredrik Unger for providing 8i6
+ * usbmon output and testing).
+ *
+ * Scarlett 18i8/18i20 Gen 3 support added in June 2020 (thanks to
+ * Darren Jaeckel, Alex Sedlack, and Clovis Lunel for providing usbmon
+ * output and testing).
+ *
+ * This ALSA mixer gives access to (model-dependent):
  *  - input, output, mixer-matrix muxes
  *  - 18x10 mixer-matrix gain stages
  *  - gain/volume controls
  *  - level meters
- *  - line/inst level and pad controls
+ *  - line/inst level, pad, and air controls
+ *  - enable/disable MSD mode
+ *  - main/alt speaker switching
  *
  * <ditaa>
  *    /--------------\    18chn            20chn     /--------------\
@@ -90,6 +103,14 @@
  *  \--------------/
  * </ditaa>
  *
+ * Gen 3 devices have a Mass Storage Device (MSD) mode where a small
+ * disk with registration and driver download information is presented
+ * to the host. To access the full functionality of the device without
+ * proprietary software, MSD mode can be disabled by:
+ * - holding down the 48V button for five seconds while powering on
+ *   the device, or
+ * - using this driver and alsamixer to change the "MSD Mode" setting
+ *   to Off, waiting two seconds, then power-cycling the device
  */
 
 #include <linux/slab.h>
@@ -108,6 +129,9 @@
 /* device_setup value to enable */
 #define SCARLETT2_ENABLE 0x01
 
+/* device_setup value to allow turning MSD mode back on */
+#define SCARLETT2_MSD_ENABLE 0x02
+
 /* some gui mixers can't handle negative ctl values */
 #define SCARLETT2_VOLUME_BIAS 127
 
@@ -141,23 +165,25 @@
 /* Maximum number of analogue outputs */
 #define SCARLETT2_ANALOGUE_MAX 10
 
-/* Maximum number of level and pad switches */
+/* Maximum number of level, pad, and air switches */
 #define SCARLETT2_LEVEL_SWITCH_MAX 2
-#define SCARLETT2_PAD_SWITCH_MAX 4
+#define SCARLETT2_PAD_SWITCH_MAX 8
+#define SCARLETT2_AIR_SWITCH_MAX 8
+#define SCARLETT2_48V_SWITCH_MAX 2
 
 /* Maximum number of inputs to the mixer */
-#define SCARLETT2_INPUT_MIX_MAX 18
+#define SCARLETT2_INPUT_MIX_MAX 24
 
 /* Maximum number of outputs from the mixer */
-#define SCARLETT2_OUTPUT_MIX_MAX 10
+#define SCARLETT2_OUTPUT_MIX_MAX 12
 
 /* Maximum size of the data in the USB mux assignment message:
- * 18 inputs, 20 outputs, 18 matrix inputs, 8 spare
+ * 18 inputs, 2 loopbacks, 20 outputs, 24 mixer inputs, 13 spare
  */
-#define SCARLETT2_MUX_MAX 64
+#define SCARLETT2_MUX_MAX 77
 
 /* Number of meters:
- * 18 inputs, 20 outputs, 18 matrix inputs
+ * 18 inputs, 20 outputs, 18 matrix inputs (XX FIXME)
  */
 #define SCARLETT2_NUM_METERS 56
 
@@ -216,6 +242,11 @@
 	u8 button_count; /* number of buttons */
 	u8 level_input_count; /* inputs with level selectable */
 	u8 pad_input_count; /* inputs with pad selectable */
+	u8 air_input_count; /* inputs with air selectable */
+	u8 power_48v_count; /* 48V phantom power */
+	u8 has_msd_mode; /* Gen 3 devices have an internal MSD mode switch */
+	u8 has_speaker_switching; /* main/alt speaker switching */
+	u8 has_talkback; /* 18i20 has Gen 3 has 'talkback' feature */
 	const char * const line_out_descrs[SCARLETT2_ANALOGUE_MAX];
 	struct scarlett2_ports ports[SCARLETT2_PORT_TYPE_COUNT];
 };
@@ -226,17 +257,33 @@
 	struct mutex data_mutex; /* lock access to this data */
 	struct delayed_work work;
 	const struct scarlett2_device_info *info;
+	__u8 interface; /* vendor-specific interface number */
+	__u8 endpoint; /* interrupt endpoint address */
+	__le16 maxpacketsize;
+	__u8 interval;
 	int num_mux_srcs;
 	u16 scarlett2_seq;
-	u8 vol_updated;
+	u8 vol_updated; /* Flag that indicates that volume has been updated */
+	u8 line_ctl_updated; /* Flag that indicates that state of PAD, INST buttons have been updated */
+	u8 speaker_updated; /* Flag that indicates that speaker/talkback has been updated */
 	u8 master_vol;
 	u8 vol[SCARLETT2_ANALOGUE_MAX];
 	u8 vol_sw_hw_switch[SCARLETT2_ANALOGUE_MAX];
 	u8 level_switch[SCARLETT2_LEVEL_SWITCH_MAX];
 	u8 pad_switch[SCARLETT2_PAD_SWITCH_MAX];
+	u8 air_switch[SCARLETT2_AIR_SWITCH_MAX];
+	u8 pow_switch[SCARLETT2_48V_SWITCH_MAX];
+	u8 msd_switch;
+	u8 speaker_switch;
+	u8 talkback_switch;
 	u8 buttons[SCARLETT2_BUTTON_MAX];
 	struct snd_kcontrol *master_vol_ctl;
+	struct snd_kcontrol *speaker_ctl;
+	struct snd_kcontrol *talkback_ctl;
 	struct snd_kcontrol *vol_ctls[SCARLETT2_ANALOGUE_MAX];
+	struct snd_kcontrol *pad_ctls[SCARLETT2_PAD_SWITCH_MAX];
+	struct snd_kcontrol *level_ctls[SCARLETT2_LEVEL_SWITCH_MAX];
+	struct snd_kcontrol *pow_ctls[SCARLETT2_48V_SWITCH_MAX];
 	struct snd_kcontrol *button_ctls[SCARLETT2_BUTTON_MAX];
 	u8 mux[SCARLETT2_MUX_MAX];
 	u8 mix[SCARLETT2_INPUT_MIX_MAX * SCARLETT2_OUTPUT_MIX_MAX];
@@ -254,10 +301,10 @@
 	.pad_input_count = 2,
 
 	.line_out_descrs = {
-		"Monitor L",
-		"Monitor R",
-		"Headphones L",
-		"Headphones R",
+		"Headphones 1 L",
+		"Headphones 1 R",
+		"Headphones 2 L",
+		"Headphones 2 R",
 	},
 
 	.ports = {
@@ -265,7 +312,6 @@
 			.id = 0x000,
 			.num = { 1, 0, 8, 8, 8 },
 			.src_descr = "Off",
-			.src_num_offset = 0,
 		},
 		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
 			.id = 0x080,
@@ -321,7 +367,6 @@
 			.id = 0x000,
 			.num = { 1, 0, 8, 8, 4 },
 			.src_descr = "Off",
-			.src_num_offset = 0,
 		},
 		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
 			.id = 0x080,
@@ -332,10 +377,6 @@
 		},
 		[SCARLETT2_PORT_TYPE_SPDIF] = {
 			.id = 0x180,
-			/* S/PDIF outputs aren't available at 192KHz
-			 * but are included in the USB mux I/O
-			 * assignment message anyway
-			 */
 			.num = { 2, 2, 2, 2, 2 },
 			.src_descr = "S/PDIF %d",
 			.src_num_offset = 1,
@@ -356,7 +397,7 @@
 		},
 		[SCARLETT2_PORT_TYPE_PCM] = {
 			.id = 0x600,
-			.num = { 20, 18, 18, 14, 10 },
+			.num = { 8, 18, 18, 14, 10 },
 			.src_descr = "PCM %d",
 			.src_num_offset = 1,
 			.dst_descr = "PCM %02d Capture"
@@ -391,7 +432,6 @@
 			.id = 0x000,
 			.num = { 1, 0, 8, 8, 6 },
 			.src_descr = "Off",
-			.src_num_offset = 0,
 		},
 		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
 			.id = 0x080,
@@ -435,6 +475,297 @@
 	},
 };
 
+static const struct scarlett2_device_info s4i4_gen3_info = {
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first two analogue inputs have an optional pad. */
+	.pad_input_count = 2,
+
+	/* The first two analogue inputs have an optional "air" feature. */
+	.air_input_count = 2,
+
+	/* One 48V phantom power switch */
+	.power_48v_count = 1,
+
+	/* Gen 3 devices have an MSD mode */
+	.has_msd_mode = 1,
+
+	.line_out_descrs = {
+		"Monitor L",
+		"Monitor R",
+		"Headphones L",
+		"Headphones R",
+	},
+
+	.ports = {
+		[SCARLETT2_PORT_TYPE_NONE] = {
+			.id = 0x000,
+			.num = { 1, 0, 16, 16, 16 },
+			.src_descr = "Off",
+		},
+		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
+			.id = 0x080,
+			.num = { 4, 4, 4, 4, 4 },
+			.src_descr = "Analogue %d",
+			.src_num_offset = 1,
+			.dst_descr = "Analogue Output %02d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_MIX] = {
+			.id = 0x300,
+			.num = { 6, 8, 8, 8, 8 },
+			.src_descr = "Mix %c",
+			.src_num_offset = 65,
+			.dst_descr = "Mixer Input %02d Capture"
+		},
+		[SCARLETT2_PORT_TYPE_PCM] = {
+			.id = 0x600,
+			.num = { 4, 6, 6, 6, 6 },
+			.src_descr = "PCM %d",
+			.src_num_offset = 1,
+			.dst_descr = "PCM %02d Capture"
+		},
+	},
+};
+
+static const struct scarlett2_device_info s8i6_gen3_info = {
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first two analogue inputs have an optional pad. */
+	.pad_input_count = 2,
+
+	/* The first two analogue inputs have an optional "air" feature. */
+	.air_input_count = 2,
+
+	/* One 48V phantom power switch */
+	.power_48v_count = 1,
+
+	/* Gen 3 devices have an MSD mode */
+	.has_msd_mode = 1,
+
+	.line_out_descrs = {
+		"Headphones 1 L",
+		"Headphones 1 R",
+		"Headphones 2 L",
+		"Headphones 2 R",
+	},
+
+	.ports = {
+		[SCARLETT2_PORT_TYPE_NONE] = {
+			.id = 0x000,
+			.num = { 1, 0, 18, 18, 18 },
+			.src_descr = "Off",
+		},
+		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
+			.id = 0x080,
+			.num = { 6, 4, 4, 4, 4 },
+			.src_descr = "Analogue %d",
+			.src_num_offset = 1,
+			.dst_descr = "Analogue Output %02d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_SPDIF] = {
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = "S/PDIF %d",
+			.src_num_offset = 1,
+			.dst_descr = "S/PDIF Output %d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_MIX] = {
+			.id = 0x300,
+			.num = { 8, 8, 8, 8, 8 },
+			.src_descr = "Mix %c",
+			.src_num_offset = 65,
+			.dst_descr = "Mixer Input %02d Capture"
+		},
+		[SCARLETT2_PORT_TYPE_PCM] = {
+			.id = 0x600,
+			.num = { 6, 10, 10, 10, 10 },
+			.src_descr = "PCM %d",
+			.src_num_offset = 1,
+			.dst_descr = "PCM %02d Capture"
+		},
+	},
+};
+
+static const struct scarlett2_device_info s18i8_gen3_info = {
+	/* The analogue line outputs on the 18i8 can be switched
+	 * between software and hardware volume control
+	 */
+	.line_out_hw_vol = 1,
+
+	/* Virtual mute and dim buttons */
+	.button_count = 2,
+
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first four analogue inputs have an optional pad. */
+	.pad_input_count = 4,
+
+	/* The first four analogue inputs have an optional "air" feature. */
+	.air_input_count = 4,
+
+	/* Two 48V phantom power switches */
+	.power_48v_count = 2,
+
+	/* Gen 3 devices have an MSD mode */
+	.has_msd_mode = 1,
+
+	/* Has a main/alt speaker switch */
+	.has_speaker_switching = 1,
+
+	.line_out_descrs = {
+		"Monitor 1 L",
+		"Monitor 1 R",
+		"Headphones 1 L",
+		"Headphones 1 R",
+		"Headphones 2 L",
+		"Headphones 2 R",
+		"Monitor 2 L",
+		"Monitor 2 R",
+	},
+
+	.ports = {
+		[SCARLETT2_PORT_TYPE_NONE] = {
+			.id = 0x000,
+			.num = { 1, 0, 10, 10, 10 },
+			.src_descr = "Off",
+			.src_num_offset = 0,
+		},
+		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
+			.id = 0x080,
+			.num = { 8, 8, 8, 8, 8 },
+			.src_descr = "Analogue %d",
+			.src_num_offset = 1,
+			.dst_descr = "Analogue Output %02d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_SPDIF] = {
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = "S/PDIF %d",
+			.src_num_offset = 1,
+			.dst_descr = "S/PDIF Output %d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_ADAT] = {
+			.id = 0x200,
+			.num = { 8, 0, 0, 0, 0 },
+			.src_descr = "ADAT %d",
+			.src_num_offset = 1,
+		},
+		[SCARLETT2_PORT_TYPE_MIX] = {
+			.id = 0x300,
+			.num = { 10, 20, 20, 20, 20 },
+			.src_descr = "Mix %c",
+			.src_num_offset = 65,
+			.dst_descr = "Mixer Input %02d Capture"
+		},
+		[SCARLETT2_PORT_TYPE_PCM] = {
+			.id = 0x600,
+			.num = { 8, 20, 20, 16, 10 },
+			.src_descr = "PCM %d",
+			.src_num_offset = 1,
+			.dst_descr = "PCM %02d Capture"
+		},
+	},
+};
+
+static const struct scarlett2_device_info s18i20_gen3_info = {
+	/* The analogue line outputs on the 18i20 can be switched
+	 * between software and hardware volume control
+	 */
+	.line_out_hw_vol = 1,
+
+	/* Mute and dim buttons */
+	.button_count = 2,
+
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first eight analogue inputs have an optional pad. */
+	.pad_input_count = 8,
+
+	/* The first eight analogue inputs have an optional "air" feature. */
+	.air_input_count = 8,
+
+	/* Two 48V phantom power switches */
+	.power_48v_count = 2,
+
+	/* Gen 3 devices have an MSD mode */
+	.has_msd_mode = 1,
+
+	/* Has a main/alt speaker switch */
+	.has_speaker_switching = 1,
+
+	/* Has a talkback speaker switch */
+	.has_talkback = 1,
+
+	.line_out_descrs = {
+		"Monitor L",
+		"Monitor R",
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		"Headphones 1 L",
+		"Headphones 1 R",
+		"Headphones 2 L",
+		"Headphones 2 R",
+	},
+
+	.ports = {
+		[SCARLETT2_PORT_TYPE_NONE] = {
+			.id = 0x000,
+			.num = { 1, 0, 13, 11, 0 },
+			.src_descr = "Off",
+			.src_num_offset = 0,
+		},
+		[SCARLETT2_PORT_TYPE_ANALOGUE] = {
+			.id = 0x080,
+			.num = { 8, 10, 10, 10, 10 },
+			.src_descr = "Analogue %d",
+			.src_num_offset = 1,
+			.dst_descr = "Analogue Output %02d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_SPDIF] = {
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = "S/PDIF %d",
+			.src_num_offset = 1,
+			.dst_descr = "S/PDIF Output %d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_ADAT] = {
+			.id = 0x200,
+			.num = { 8, 8, 8, 8, 0 },
+			.src_descr = "ADAT %d",
+			.src_num_offset = 1,
+			.dst_descr = "ADAT Output %d Playback"
+		},
+		[SCARLETT2_PORT_TYPE_MIX] = {
+			.id = 0x300,
+			.num = { 12, 24, 24, 24, 24 },
+			.src_descr = "Mix %c",
+			.src_num_offset = 65,
+			.dst_descr = "Mixer Input %02d Capture"
+		},
+		[SCARLETT2_PORT_TYPE_PCM] = {
+			.id = 0x600,
+			.num = { 20, 20, 20, 18, 10 },
+			.src_descr = "PCM %d",
+			.src_num_offset = 1,
+			.dst_descr = "PCM %02d Capture"
+		},
+	},
+};
+
 /* get the starting port index number for a given port type/direction */
 static int scarlett2_get_port_start_num(const struct scarlett2_ports *ports,
 					int direction, int port_type)
@@ -449,21 +780,21 @@
 
 /*** USB Interactions ***/
 
-/* Vendor-Specific Interface, Endpoint, MaxPacketSize, Interval */
-#define SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE 5
-#define SCARLETT2_USB_INTERRUPT_ENDPOINT 4
-#define SCARLETT2_USB_INTERRUPT_MAX_DATA 64
-#define SCARLETT2_USB_INTERRUPT_INTERVAL 3
-
-/* Interrupt flags for volume and mute/dim button changes */
-#define SCARLETT2_USB_INTERRUPT_VOL_CHANGE 0x400000
-#define SCARLETT2_USB_INTERRUPT_BUTTON_CHANGE 0x200000
+/* Interrupt flags for volume, mute/dim button, and sync changes */
+#define SCARLETT2_USB_INTERRUPT_ACK 0x00000001
+#define SCARLETT2_USB_INTERRUPT_SYNC_CHANGE 0x00000008
+#define SCARLETT2_USB_INTERRUPT_BUTTON_CHANGE 0x00200000
+#define SCARLETT2_USB_INTERRUPT_VOL_CHANGE 0x00400000
+#define SCARLETT2_USB_INTERRUPT_LINE_CTL_CHANGE 0x00800000
+#define SCARLETT2_USB_INTERRUPT_SPEAKER_CHANGE 0x01000000
 
 /* Commands for sending/receiving requests/responses */
-#define SCARLETT2_USB_VENDOR_SPECIFIC_CMD_REQ 2
-#define SCARLETT2_USB_VENDOR_SPECIFIC_CMD_RESP 3
+#define SCARLETT2_USB_CMD_INIT 0
+#define SCARLETT2_USB_CMD_REQ 2
+#define SCARLETT2_USB_CMD_RESP 3
 
-#define SCARLETT2_USB_INIT_SEQ 0x00000000
+#define SCARLETT2_USB_INIT_1 0x00000000
+#define SCARLETT2_USB_INIT_2 0x00000002
 #define SCARLETT2_USB_GET_METER_LEVELS 0x00001001
 #define SCARLETT2_USB_SET_MIX 0x00002002
 #define SCARLETT2_USB_SET_MUX 0x00003002
@@ -478,25 +809,26 @@
 /* volume status is read together (matches scarlett2_config_items[]) */
 struct scarlett2_usb_volume_status {
 	/* mute & dim buttons */
-	u8 buttons[SCARLETT2_BUTTON_MAX];
+	u8 buttons[SCARLETT2_BUTTON_MAX]; /* 0x31 */
 
-	u8 pad1;
+	u8 pad1; /* 0x33 */
 
 	/* software volume setting */
-	s16 sw_vol[SCARLETT2_ANALOGUE_MAX];
+	s16 sw_vol[SCARLETT2_ANALOGUE_MAX]; /* 0x34 */
 
 	/* actual volume of output inc. dim (-18dB) */
-	s16 hw_vol[SCARLETT2_ANALOGUE_MAX];
+	s16 hw_vol[SCARLETT2_ANALOGUE_MAX]; /* 0x48 */
 
-	u8 pad2[SCARLETT2_ANALOGUE_MAX];
+        /* mute? */
+	u8 mute[SCARLETT2_ANALOGUE_MAX]; /* 0x5C */
 
 	/* sw (0) or hw (1) controlled */
-	u8 sw_hw_switch[SCARLETT2_ANALOGUE_MAX];
+	u8 sw_hw_switch[SCARLETT2_ANALOGUE_MAX]; /* 0x66 */
 
-	u8 pad3[6];
+	u8 pad3[6]; /* 0x70 */
 
 	/* front panel volume knob */
-	s16 master_vol;
+	s16 master_vol; /* 0x76 */
 } __packed;
 
 /* Configuration parameters that can be read and written */
@@ -506,7 +838,15 @@
 	SCARLETT2_CONFIG_SW_HW_SWITCH = 2,
 	SCARLETT2_CONFIG_LEVEL_SWITCH = 3,
 	SCARLETT2_CONFIG_PAD_SWITCH = 4,
-	SCARLETT2_CONFIG_COUNT = 5
+	SCARLETT2_CONFIG_AIR_SWITCH = 5,
+	SCARLETT2_CONFIG_SPDIF_SWITCH = 6,
+	SCARLETT2_CONFIG_48V_SWITCH = 7,
+	SCARLETT2_CONFIG_MSD_SWITCH = 8,
+	SCARLETT2_CONFIG_MAIN_ALT_SPEAKER_SWITCH = 9,
+	SCARLETT2_CONFIG_SPEAKER_SWITCHING_SWITCH = 10,
+	SCARLETT2_CONFIG_GAIN_HALO_1 = 11,
+	SCARLETT2_CONFIG_GAIN_HALO_2 = 12,
+	SCARLETT2_CONFIG_COUNT = 13
 };
 
 /* Location, size, and activation command number for the configuration
@@ -553,6 +893,62 @@
 		.offset = 0x84,
 		.size = 1,
 		.activate = 8
+	},
+
+	/* Air Switch */
+	{
+		.offset = 0x8c,
+		.size = 1,
+		.activate = 8
+	},
+
+	/* S/PDIF Source */
+	{
+		.offset = 0x94,
+		.size = 1,
+		.activate = 6
+	},
+
+	/* Phantom (48V) power */
+	{
+		.offset = 0x9c,
+		.size = 1,
+		.activate = 8
+	},
+
+	/* MSD Mode */
+	{
+		.offset = 0x9d,
+		.size = 1,
+		.activate = 6
+	},
+
+	/* Alternate Speaker and Talkback switches */
+	{
+		.offset = 0x9f,
+		.size = 1,
+		.activate = 10
+	},
+
+	/* Speaker Switching */
+	{
+		.offset = 0xa0,
+		.size = 1,
+		.activate = 10
+	},
+
+	/* Gain Halos */
+	{
+		.offset = 0xa1,
+		.size = 1,
+		.activate = 9
+	},
+
+	/* Gain Halo? */
+	{
+		.offset = 0xa8,
+		.size = 1,
+		.activate = 11
 	}
 };
 
@@ -566,8 +962,6 @@
 	u8 data[];
 };
 
-#define SCARLETT2_USB_PACKET_LEN (sizeof(struct scarlett2_usb_packet))
-
 static void scarlett2_fill_request_header(struct scarlett2_mixer_data *private,
 					  struct scarlett2_usb_packet *req,
 					  u32 cmd, u16 req_size)
@@ -582,16 +976,84 @@
 	req->pad = 0;
 }
 
+static int scarlett2_usb_tx(struct usb_device *dev, int interface,
+			    void *buf, u16 size)
+{
+	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),
+			SCARLETT2_USB_CMD_REQ,
+			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
+			0, interface, buf, size);
+}
+
+static int scarlett2_usb_rx(struct usb_device *dev, int interface,
+			    u32 usb_req, void *buf, u16 size)
+{
+	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),
+			usb_req,
+			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
+			0, interface, buf, size);
+}
+
+static int scarlett2_usb(
+	struct usb_mixer_interface *mixer, u32 cmd,
+	void *req_data, u16 req_size, void *resp_data, u16 resp_size);
+
+/* Cargo cult proprietary initialisation sequence */
+static int scarlett2_usb_init(struct usb_mixer_interface *mixer)
+{
+	struct snd_usb_audio *chip = mixer->chip;
+	struct usb_device *dev = chip->dev;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	u16 buf_size = sizeof(struct scarlett2_usb_packet) + 8;
+	struct scarlett2_usb_packet *buf;
+	int err;
+
+	if (snd_usb_pipe_sanity_check(dev, usb_sndctrlpipe(dev, 0))) {
+		return -EINVAL;
+	}
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	// step 0
+	err = scarlett2_usb_rx(dev, private->interface, SCARLETT2_USB_CMD_INIT,
+			       buf, buf_size);
+	if (err < 0)
+		goto error;
+
+	// step 1
+	private->scarlett2_seq = 1;
+	err = scarlett2_usb(mixer, SCARLETT2_USB_INIT_1, NULL, 0, NULL, 0);
+	if (err < 0)
+		goto error;
+
+	// step 2
+	private->scarlett2_seq = 1;
+	err = scarlett2_usb(mixer, SCARLETT2_USB_INIT_2, NULL, 0, NULL, 84);
+	if (err < 0)
+		goto error;
+
+	err = 0;
+
+error:
+	kfree(buf);
+	return err;
+}
+
 /* Send a proprietary format request to the Scarlett interface */
 static int scarlett2_usb(
 	struct usb_mixer_interface *mixer, u32 cmd,
 	void *req_data, u16 req_size, void *resp_data, u16 resp_size)
 {
 	struct scarlett2_mixer_data *private = mixer->private_data;
+	struct usb_device *dev = mixer->chip->dev;
 	u16 req_buf_size = sizeof(struct scarlett2_usb_packet) + req_size;
 	u16 resp_buf_size = sizeof(struct scarlett2_usb_packet) + resp_size;
-	struct scarlett2_usb_packet *req = NULL, *resp = NULL;
-	int err = 0;
+	struct scarlett2_usb_packet *req, *resp = NULL;
+	int err;
 
 	req = kmalloc(req_buf_size, GFP_KERNEL);
 	if (!req) {
@@ -614,14 +1076,7 @@
 	if (req_size)
 		memcpy(req->data, req_data, req_size);
 
-	err = snd_usb_ctl_msg(mixer->chip->dev,
-			usb_sndctrlpipe(mixer->chip->dev, 0),
-			SCARLETT2_USB_VENDOR_SPECIFIC_CMD_REQ,
-			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
-			0,
-			SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE,
-			req,
-			req_buf_size);
+	err = scarlett2_usb_tx(dev, private->interface, req, req_buf_size);
 
 	if (err != req_buf_size) {
 		usb_audio_err(
@@ -634,28 +1089,25 @@
 
 	/* send a second message to get the response */
 
-	err = snd_usb_ctl_msg(mixer->chip->dev,
-			usb_sndctrlpipe(mixer->chip->dev, 0),
-			SCARLETT2_USB_VENDOR_SPECIFIC_CMD_RESP,
-			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
-			0,
-			SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE,
-			resp,
-			resp_buf_size);
+	err = scarlett2_usb_rx(dev, private->interface, SCARLETT2_USB_CMD_RESP,
+			       resp, resp_buf_size);
 
 	/* validate the response */
 
 	if (err != resp_buf_size) {
 		usb_audio_err(
 			mixer->chip,
-			"Scarlett Gen 2 USB response result cmd %x was %d\n",
-			cmd, err);
+			"Scarlett Gen 2 USB response result cmd %x was %d expected %d\n",
+			cmd, err, resp_buf_size);
 		err = -EINVAL;
 		goto unlock;
 	}
 
+	/* cmd/seq/size should match except when initialising
+	 * seq sent = 1, response = 0
+	 */
 	if (resp->cmd != req->cmd ||
-	    resp->seq != req->seq ||
+	    (resp->seq != req->seq && (req->seq != 1 || resp->seq != 0)) ||
 	    resp_size != le16_to_cpu(resp->size) ||
 	    resp->error ||
 	    resp->pad) {
@@ -673,7 +1125,7 @@
 		goto unlock;
 	}
 
-	if (resp_size > 0)
+	if (resp_data && resp_size > 0)
 		memcpy(resp_data, resp->data, resp_size);
 
 unlock:
@@ -704,7 +1156,7 @@
 }
 
 /* Send a USB message to set a configuration parameter (volume level,
- * sw/hw volume switch, line/inst level switch, or pad switch)
+ * sw/hw volume switch, line/inst level switch, pad, or air switch)
  */
 static int scarlett2_usb_set_config(
 	struct usb_mixer_interface *mixer,
@@ -890,10 +1342,6 @@
 							ports, private->mux[j]
 						) << 12
 					  );
-
-			/* skip private->mux[j] entries not output */
-			j += ports[port_type].num[SCARLETT2_PORT_OUT] -
-			     ports[port_type].num[port_dir_rate];
 		}
 
 		err = scarlett2_usb(mixer, SCARLETT2_USB_SET_MUX,
@@ -1196,6 +1644,61 @@
 };
 
 /*** Line Level/Instrument Level Switch Controls ***/
+static int scarlett2_update_line_ctl_switches(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	u8 pad_switches[SCARLETT2_PAD_SWITCH_MAX];
+	u8 level_switches[SCARLETT2_LEVEL_SWITCH_MAX];
+	u8 pow_switch;
+
+	int i, err = 0;
+
+	private->line_ctl_updated = 0;
+
+	/* Update pad settings */
+	if (info->pad_input_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_PAD_SWITCH,
+			info->pad_input_count,
+			pad_switches);
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < info->pad_input_count; i++)
+			private->pad_switch[i] = !!pad_switches[i];
+	}
+
+	/* Update level settings */
+	if (info->level_input_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_LEVEL_SWITCH,
+			info->level_input_count,
+			level_switches);
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < info->level_input_count; i++)
+			private->level_switch[i] = !!level_switches[i];
+	}
+
+	/* Update phantom power settings */
+	if (info->power_48v_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_48V_SWITCH,
+			1, &pow_switch);
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < info->power_48v_count; i++)
+			private->pow_switch[i] = !! (pow_switch & (1 << i));
+	}
+
+	return 0;
+}
 
 static int scarlett2_level_enum_ctl_info(struct snd_kcontrol *kctl,
 					 struct snd_ctl_elem_info *uinfo)
@@ -1211,7 +1714,14 @@
 					struct snd_ctl_elem_value *ucontrol)
 {
 	struct usb_mixer_elem_info *elem = kctl->private_data;
-	struct scarlett2_mixer_data *private = elem->head.mixer->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	
+	if (private->line_ctl_updated) {
+		mutex_lock(&private->data_mutex);
+		scarlett2_update_line_ctl_switches(mixer);
+		mutex_unlock(&private->data_mutex);
+	}
 
 	ucontrol->value.enumerated.item[0] =
 		private->level_switch[elem->control];
@@ -1256,12 +1766,18 @@
 };
 
 /*** Pad Switch Controls ***/
-
 static int scarlett2_pad_ctl_get(struct snd_kcontrol *kctl,
 				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct usb_mixer_elem_info *elem = kctl->private_data;
-	struct scarlett2_mixer_data *private = elem->head.mixer->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	if (private->line_ctl_updated) {
+		mutex_lock(&private->data_mutex);
+		scarlett2_update_line_ctl_switches(mixer);
+		mutex_unlock(&private->data_mutex);
+	}
 
 	ucontrol->value.enumerated.item[0] =
 		private->pad_switch[elem->control];
@@ -1288,7 +1804,7 @@
 
 	private->pad_switch[index] = val;
 
-	/* Send switch change to the device */
+	/* Send pad change to the device */
 	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_PAD_SWITCH,
 				       index, val);
 
@@ -1305,6 +1821,115 @@
 	.put  = scarlett2_pad_ctl_put,
 };
 
+/*** Air Switch Controls ***/
+
+static int scarlett2_air_ctl_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_mixer_data *private = elem->head.mixer->private_data;
+
+	ucontrol->value.enumerated.item[0] =
+		private->air_switch[elem->control];
+	return 0;
+}
+
+static int scarlett2_air_ctl_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	int index = elem->control;
+	int oval, val, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	oval = private->air_switch[index];
+	val = !!ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->air_switch[index] = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_AIR_SWITCH,
+				       index, val);
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_air_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_air_ctl_get,
+	.put  = scarlett2_air_ctl_put,
+};
+
+/*** 48V Switch Controls ***/
+static int scarlett2_48v_ctl_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	
+	if (private->line_ctl_updated) {
+		mutex_lock(&private->data_mutex);
+		scarlett2_update_line_ctl_switches(mixer);
+		mutex_unlock(&private->data_mutex);
+	}
+
+	ucontrol->value.enumerated.item[0] =
+		private->pow_switch[elem->control];
+	return 0;
+}
+
+static int scarlett2_48v_ctl_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+
+	int index = elem->control;
+	int i, oval, val, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	oval = private->pow_switch[index];
+	val = !!ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->pow_switch[index] = val;
+	val = 0;
+	for (i = 0; i < info->power_48v_count; ++i)
+		val |= (private->pow_switch[i] << i);
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_48V_SWITCH, 0, val);
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_48v_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_48v_ctl_get,
+	.put  = scarlett2_48v_ctl_put
+};
+
 /*** Mute/Dim Controls ***/
 
 static int scarlett2_button_ctl_get(struct snd_kcontrol *kctl,
@@ -1432,7 +2057,6 @@
 }
 
 /*** Create the analogue input controls ***/
-
 static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 {
 	struct scarlett2_mixer_data *private = mixer->private_data;
@@ -1442,22 +2066,40 @@
 
 	/* Add input level (line/inst) controls */
 	for (i = 0; i < info->level_input_count; i++) {
-		snprintf(s, sizeof(s), "Line In %d Level Capture Enum", i + 1);
+		snprintf(s, sizeof(s), "Line In %d Mode Switch", i + 1);
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_level_enum_ctl,
-					    i, 1, s, NULL);
+					    i, 1, s, &private->level_ctls[i]);
 		if (err < 0)
 			return err;
 	}
 
 	/* Add input pad controls */
 	for (i = 0; i < info->pad_input_count; i++) {
-		snprintf(s, sizeof(s), "Line In %d Pad Capture Switch", i + 1);
+		snprintf(s, sizeof(s), "Line In %d Pad Switch", i + 1);
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_pad_ctl,
+					    i, 1, s, &private->pad_ctls[i]);
+		if (err < 0)
+			return err;
+	}
+
+	/* Add input air controls */
+	for (i = 0; i < info->air_input_count; i++) {
+		snprintf(s, sizeof(s), "Line In %d Air Switch", i + 1);
+		err = scarlett2_add_new_ctl(mixer, &scarlett2_air_ctl,
 					    i, 1, s, NULL);
 		if (err < 0)
 			return err;
 	}
 
+	/* Add input 48v controls */
+	for (i = 0; i < info->power_48v_count; i++) {
+		snprintf(s, sizeof(s), "Line 48V Switch %d", i + 1);
+		err = scarlett2_add_new_ctl(mixer, &scarlett2_48v_ctl,
+					    i, 1, s, &private->pow_ctls[i]);
+		if (err < 0)
+			return err;
+	}
+
 	return 0;
 }
 
@@ -1495,18 +2137,19 @@
 	const struct scarlett2_device_info *info = private->info;
 	const struct scarlett2_ports *ports = info->ports;
 	int oval, val, num_mixer_in, mix_num, err = 0;
+	int index = elem->control;
 
 	mutex_lock(&private->data_mutex);
 
-	oval = private->mix[elem->control];
+	oval = private->mix[index];
 	val = ucontrol->value.integer.value[0];
 	num_mixer_in = ports[SCARLETT2_PORT_TYPE_MIX].num[SCARLETT2_PORT_OUT];
-	mix_num = elem->control / num_mixer_in;
+	mix_num = index / num_mixer_in;
 
 	if (oval == val)
 		goto unlock;
 
-	private->mix[elem->control] = val;
+	private->mix[index] = val;
 	err = scarlett2_usb_set_mix(mixer, mix_num);
 	if (err == 0)
 		err = 1;
@@ -1717,6 +2360,262 @@
 				     "Level Meter", NULL);
 }
 
+/*** MSD Controls ***/
+
+static int scarlett2_msd_ctl_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_mixer_data *private = elem->head.mixer->private_data;
+
+	ucontrol->value.enumerated.item[0] = private->msd_switch;
+	return 0;
+}
+
+static int scarlett2_msd_ctl_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	int oval, val, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	oval = private->msd_switch;
+	val = !!ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->msd_switch = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_MSD_SWITCH,
+				       0, val);
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_msd_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_msd_ctl_get,
+	.put  = scarlett2_msd_ctl_put,
+};
+
+static int scarlett2_add_msd_ctl(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+
+	if (!info->has_msd_mode)
+		return 0;
+
+	/* If MSD mode is off, hide the switch by default */
+	if (!private->msd_switch && !(mixer->chip->setup & SCARLETT2_MSD_ENABLE))
+		return 0;
+
+	/* Add MSD control */
+	return scarlett2_add_new_ctl(mixer, &scarlett2_msd_ctl,
+				     0, 1, "MSD Mode", NULL);
+}
+
+/*** Speaker Switching Control ***/
+static int scarlett2_update_speaker_switch_enum_ctl(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	u8 speaker_switching, speaker_switch;
+	int err = 0;
+
+	private->speaker_updated = 0;
+	if (!info->has_speaker_switching)
+		return 0;
+
+	/* check if speaker switching is enabled */
+	err = scarlett2_usb_get_config(
+		mixer,
+		SCARLETT2_CONFIG_SPEAKER_SWITCHING_SWITCH,
+		1, &speaker_switching);
+	if (err < 0)
+		return err;
+
+	/* get actual speaker & talkback configuration */
+	err = scarlett2_usb_get_config(
+		mixer,
+		SCARLETT2_CONFIG_MAIN_ALT_SPEAKER_SWITCH,
+		1, &speaker_switch);
+	if (err < 0)
+		return err;
+
+	/* decode speaker & talkback values */
+	private->speaker_switch  = (speaker_switching) ? (speaker_switch & 1) + 1 : 0;
+	if (info->has_talkback)
+		private->talkback_switch = !!(speaker_switch & 2);
+
+	return 0;
+}
+
+static int scarlett2_speaker_switch_enum_ctl_info(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
+{
+	static const char *const values[3] = {
+		"Off", "Main", "Alt"
+	};
+
+	return snd_ctl_enum_info(uinfo, 1, 3, values);
+}
+
+static int scarlett2_speaker_switch_enum_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	
+	if (private->speaker_updated) {
+		mutex_lock(&private->data_mutex);
+		scarlett2_update_speaker_switch_enum_ctl(mixer);
+		mutex_unlock(&private->data_mutex);
+	}
+
+	ucontrol->value.enumerated.item[0] =
+		private->speaker_switch;
+	return 0;
+}
+
+static int scarlett2_talkback_switch_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	if (private->speaker_updated) {
+		mutex_lock(&private->data_mutex);
+		scarlett2_update_speaker_switch_enum_ctl(mixer);
+		mutex_unlock(&private->data_mutex);
+	}
+
+	ucontrol->value.enumerated.item[0] =
+		private->talkback_switch;
+	return 0;
+}
+
+static int scarlett2_speaker_switch_update_state(struct usb_mixer_interface *mixer, int alt, int talkback) {
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int old_alt, old_talk, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	old_alt = private->speaker_switch;
+	old_talk = private->talkback_switch;
+
+	if ((old_alt == alt) && (old_talk == talkback))
+		goto unlock;
+
+	private->speaker_switch = alt;
+	private->talkback_switch = talkback;
+	
+	/* enable/disable speaker switching */
+	if (old_alt == 0 || alt == 0) {
+		err = scarlett2_usb_set_config(
+			mixer, SCARLETT2_CONFIG_SPEAKER_SWITCHING_SWITCH,
+			0, !!alt);
+	}
+
+	/* update talkback speaker and talkback */
+	if (!err) {
+		int val = (alt == 2);
+		if (info->has_talkback)
+			val |= talkback << 1;
+
+		err = scarlett2_usb_set_config(
+			mixer, SCARLETT2_CONFIG_MAIN_ALT_SPEAKER_SWITCH,
+			0, val);
+	}
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_speaker_switch_enum_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	return scarlett2_speaker_switch_update_state(mixer, 
+						     ucontrol->value.integer.value[0],
+						     private->talkback_switch);
+}
+
+static int scarlett2_talkback_switch_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	return scarlett2_speaker_switch_update_state(mixer, 
+						     private->speaker_switch,
+						     ucontrol->value.integer.value[0]);
+}
+
+static const struct snd_kcontrol_new scarlett2_speaker_switch_enum_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = scarlett2_speaker_switch_enum_ctl_info,
+	.get  = scarlett2_speaker_switch_enum_ctl_get,
+	.put  = scarlett2_speaker_switch_enum_ctl_put,
+};
+
+static const struct snd_kcontrol_new scarlett2_talkback_switch_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_talkback_switch_ctl_get,
+	.put  = scarlett2_talkback_switch_ctl_put,
+};
+
+static int scarlett2_add_speaker_switch_ctl(
+	struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int err = 0;
+
+	if (info->has_speaker_switching) {
+		/* Add speaker switching control */
+		err = scarlett2_add_new_ctl(
+			mixer, &scarlett2_speaker_switch_enum_ctl,
+			0, 1, "Speaker Switching", &private->speaker_ctl);
+		
+		if (err < 0)
+			return err;
+	}
+	
+	if (info->has_talkback) {
+		/* Add talkback switching control */
+		err = scarlett2_add_new_ctl(
+			mixer, &scarlett2_talkback_switch_ctl,
+			0, 1, "Talkback Switching", &private->talkback_ctl);
+		
+		if (err < 0)
+			return err;
+	}
+	
+	return 0;
+}
+
 /*** Cleanup/Suspend Callbacks ***/
 
 static void scarlett2_private_free(struct usb_mixer_interface *mixer)
@@ -1803,12 +2702,42 @@
 	}
 }
 
+/* Look through the interface descriptors for the Focusrite Control
+ * interface (bInterfaceClass = 255 Vendor Specific Class) and set the
+ * interface number, endpoint address, packet size, and interval in
+ * private
+ */
+static int scarlett2_find_fc_interface(struct usb_device *dev,
+				       struct scarlett2_mixer_data *private) {
+	struct usb_host_config *config = dev->actconfig;
+	int i;
+
+	for (i = 0; i < config->desc.bNumInterfaces; i++) {
+		struct usb_interface *intf = config->interface[i];
+		struct usb_interface_descriptor *desc =
+			&intf->altsetting[0].desc;
+		if (desc->bInterfaceClass == 255) {
+			struct usb_endpoint_descriptor *epd =
+				get_endpoint(intf->altsetting, 0);
+			private->interface = desc->bInterfaceNumber;
+			private->endpoint = epd->bEndpointAddress &
+				USB_ENDPOINT_NUMBER_MASK;
+			private->maxpacketsize = epd->wMaxPacketSize;
+			private->interval = epd->bInterval;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
 /* Initialise private data, routing, sequence number */
 static int scarlett2_init_private(struct usb_mixer_interface *mixer,
 				  const struct scarlett2_device_info *info)
 {
 	struct scarlett2_mixer_data *private =
 		kzalloc(sizeof(struct scarlett2_mixer_data), GFP_KERNEL);
+	int err;
 
 	if (!private)
 		return -ENOMEM;
@@ -1816,19 +2745,25 @@
 	mutex_init(&private->usb_mutex);
 	mutex_init(&private->data_mutex);
 	INIT_DELAYED_WORK(&private->work, scarlett2_config_save_work);
+	mixer->private_data = private;
+	mixer->private_free = scarlett2_private_free;
+	mixer->private_suspend = scarlett2_private_suspend;
 	private->info = info;
 	private->num_mux_srcs = scarlett2_count_mux_srcs(info->ports);
 	private->scarlett2_seq = 0;
 	private->mixer = mixer;
-	mixer->private_data = private;
-	mixer->private_free = scarlett2_private_free;
-	mixer->private_suspend = scarlett2_private_suspend;
+	private->vol_updated = 0;
+	private->line_ctl_updated = 0;
+	private->talkback_switch = 0;
+	err = scarlett2_find_fc_interface(mixer->chip->dev, private);
+
+	if (err < 0)
+		return -EINVAL;
 
 	/* Setup default routing */
 	scarlett2_init_routing(private->mux, info->ports);
 
-	/* Initialise the sequence number used for the proprietary commands */
-	return scarlett2_usb(mixer, SCARLETT2_USB_INIT_SEQ, NULL, 0, NULL, 0);
+	return 0;
 }
 
 /* Read line-in config and line-out volume settings on start */
@@ -1841,9 +2776,14 @@
 		ports[SCARLETT2_PORT_TYPE_ANALOGUE].num[SCARLETT2_PORT_OUT];
 	u8 level_switches[SCARLETT2_LEVEL_SWITCH_MAX];
 	u8 pad_switches[SCARLETT2_PAD_SWITCH_MAX];
+	u8 air_switches[SCARLETT2_AIR_SWITCH_MAX];
+	u8 msd_switch;
+	u8 speaker_switching, speaker_switch;
+	u8 pow_switch;
 	struct scarlett2_usb_volume_status volume_status;
 	int err, i;
 
+	/* INST buttons */
 	if (info->level_input_count) {
 		err = scarlett2_usb_get_config(
 			mixer,
@@ -1856,6 +2796,7 @@
 			private->level_switch[i] = level_switches[i];
 	}
 
+	/* PAD buttons */
 	if (info->pad_input_count) {
 		err = scarlett2_usb_get_config(
 			mixer,
@@ -1868,6 +2809,68 @@
 			private->pad_switch[i] = pad_switches[i];
 	}
 
+	/* AIR input settings */
+	if (info->air_input_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_AIR_SWITCH,
+			info->air_input_count,
+			air_switches);
+		if (err < 0)
+			return err;
+		for (i = 0; i < info->air_input_count; i++)
+			private->air_switch[i] = air_switches[i];
+	}
+
+	/* Phantom power settings */
+	if (info->power_48v_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_48V_SWITCH,
+			1, &pow_switch);
+		if (err < 0)
+			return err;
+		
+		for (i = 0; i < info->power_48v_count; i++)
+			private->pow_switch[i] = !! (pow_switch & (1 << i));
+	}
+
+	/* Mass Storage Device (MSD) settings */
+	if (info->has_msd_mode) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_MSD_SWITCH,
+			1,
+			&msd_switch);
+		if (err < 0)
+			return err;
+		private->msd_switch = msd_switch;
+	}
+
+	/* Speaker switching (ALT button) and optional TALKBACK button */
+	if (info->has_speaker_switching) {
+		/* check if speaker switching is enabled */
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_SPEAKER_SWITCHING_SWITCH,
+			1, &speaker_switching);
+		if (err < 0)
+			return err;
+	
+		/* get actual speaker & talkback configuration */
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_MAIN_ALT_SPEAKER_SWITCH,
+			1, &speaker_switch);
+		if (err < 0)
+			return err;
+
+		/* decode speaker & talkback values */
+		private->speaker_switch  = (speaker_switching) ? (speaker_switch & 1) + 1 : 0;
+		if (info->has_talkback)
+			private->talkback_switch = !!(speaker_switch & 2);
+	}
+
 	err = scarlett2_usb_get_volume_status(mixer, &volume_status);
 	if (err < 0)
 		return err;
@@ -1920,6 +2923,45 @@
 	}
 }
 
+/* Notify on PAD/INST/48V button state change */
+static void scarlett2_mixer_interrupt_line_in_ctl_change(
+	struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int i;
+
+	/* Trigger all PAD inputs for changes */
+	if (info->pad_input_count) {
+		private->line_ctl_updated = 1;
+
+		for (i = 0; i < info->pad_input_count; i++) {
+			snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &private->pad_ctls[i]->id);
+		}
+	}
+	
+	/* Trigger all INST inputs for changes */
+	if (info->level_input_count) {
+		private->line_ctl_updated = 1;
+
+		for (i = 0; i < info->level_input_count; i++) {
+			snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &private->level_ctls[i]->id);
+		}
+	}
+
+	/* Trigger all 48V inputs for changes */
+	if (info->power_48v_count) {
+		private->line_ctl_updated = 1;
+
+		for (i = 0; i < info->power_48v_count; i++) {
+			snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &private->pow_ctls[i]->id);
+		}
+	}
+}
+
 /* Notify on button change */
 static void scarlett2_mixer_interrupt_button_change(
 	struct usb_mixer_interface *mixer)
@@ -1934,23 +2976,42 @@
 			       &private->button_ctls[i]->id);
 }
 
+/* Notify on speaker change */
+static void scarlett2_mixer_interrupt_speaker_change(
+	struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer->private_data;
+
+	private->speaker_updated = 1;
+
+	snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+		       &private->speaker_ctl->id);
+
+	if (private->info->has_talkback)
+		snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &private->talkback_ctl->id);
+}
+
 /* Interrupt callback */
 static void scarlett2_mixer_interrupt(struct urb *urb)
 {
 	struct usb_mixer_interface *mixer = urb->context;
 	int len = urb->actual_length;
 	int ustatus = urb->status;
-	u32 data;
 
 	if (ustatus != 0)
 		goto requeue;
 
 	if (len == 8) {
-		data = le32_to_cpu(*(u32 *)urb->transfer_buffer);
+		u32 data = le32_to_cpu(*(u32 *)urb->transfer_buffer);
 		if (data & SCARLETT2_USB_INTERRUPT_VOL_CHANGE)
 			scarlett2_mixer_interrupt_vol_change(mixer);
+		if (data & SCARLETT2_USB_INTERRUPT_LINE_CTL_CHANGE)
+			scarlett2_mixer_interrupt_line_in_ctl_change(mixer);
 		if (data & SCARLETT2_USB_INTERRUPT_BUTTON_CHANGE)
 			scarlett2_mixer_interrupt_button_change(mixer);
+		if (data & SCARLETT2_USB_INTERRUPT_SPEAKER_CHANGE)
+			scarlett2_mixer_interrupt_speaker_change(mixer);
 	} else {
 		usb_audio_err(mixer->chip,
 			      "scarlett mixer interrupt length %d\n", len);
@@ -1968,8 +3029,8 @@
 static int scarlett2_mixer_status_create(struct usb_mixer_interface *mixer)
 {
 	struct usb_device *dev = mixer->chip->dev;
-	unsigned int pipe = usb_rcvintpipe(dev,
-					   SCARLETT2_USB_INTERRUPT_ENDPOINT);
+	struct scarlett2_mixer_data *private = mixer->private_data;
+	unsigned int pipe = usb_rcvintpipe(dev, private->endpoint);
 	void *transfer_buffer;
 
 	if (mixer->urb) {
@@ -1985,14 +3046,14 @@
 	if (!mixer->urb)
 		return -ENOMEM;
 
-	transfer_buffer = kmalloc(SCARLETT2_USB_INTERRUPT_MAX_DATA, GFP_KERNEL);
+	transfer_buffer = kmalloc(private->maxpacketsize, GFP_KERNEL);
 	if (!transfer_buffer)
 		return -ENOMEM;
 
 	usb_fill_int_urb(mixer->urb, dev, pipe,
-			 transfer_buffer, SCARLETT2_USB_INTERRUPT_MAX_DATA,
+			 transfer_buffer, private->maxpacketsize,
 			 scarlett2_mixer_interrupt, mixer,
-			 SCARLETT2_USB_INTERRUPT_INTERVAL);
+			 private->interval);
 
 	return usb_submit_urb(mixer->urb, GFP_KERNEL);
 }
@@ -2000,6 +3061,7 @@
 /* Entry point */
 int snd_scarlett_gen2_controls_create(struct usb_mixer_interface *mixer)
 {
+	struct snd_usb_audio *chip = mixer->chip;
 	const struct scarlett2_device_info *info;
 	int err;
 
@@ -2007,7 +3069,7 @@
 	if (!mixer->protocol)
 		return 0;
 
-	switch (mixer->chip->usb_id) {
+	switch (chip->usb_id) {
 	case USB_ID(0x1235, 0x8203):
 		info = &s6i6_gen2_info;
 		break;
@@ -2017,23 +3079,45 @@
 	case USB_ID(0x1235, 0x8201):
 		info = &s18i20_gen2_info;
 		break;
+	case USB_ID(0x1235, 0x8212):
+		info = &s4i4_gen3_info;
+		break;
+	case USB_ID(0x1235, 0x8213):
+		info = &s8i6_gen3_info;
+		break;
+	case USB_ID(0x1235, 0x8214):
+		info = &s18i8_gen3_info;
+		break;
+	case USB_ID(0x1235, 0x8215):
+		info = &s18i20_gen3_info;
+		break;
 	default: /* device not (yet) supported */
 		return -EINVAL;
 	}
 
-	if (!(mixer->chip->setup & SCARLETT2_ENABLE)) {
-		usb_audio_err(mixer->chip,
-			"Focusrite Scarlett Gen 2 Mixer Driver disabled; "
-			"use options snd_usb_audio device_setup=1 "
-			"to enable and report any issues to g@b4.vu");
+	if (!(chip->setup & SCARLETT2_ENABLE)) {
+		usb_audio_err(chip,
+			"Focusrite Scarlett Gen 2/3 Mixer Driver disabled; "
+			"use options snd_usb_audio vid=0x%04x pid=0x%04x "
+			"device_setup=1 to enable and report any issues "
+			"to g@b4.vu",
+			USB_ID_VENDOR(chip->usb_id),
+			USB_ID_PRODUCT(chip->usb_id));
 		return 0;
 	}
 
+	usb_audio_err(chip, "Focusrite Scarlett Gen 2/3 Mixer Driver enabled pid=0x%04x", USB_ID_PRODUCT(chip->usb_id));
+
 	/* Initialise private data, routing, sequence number */
 	err = scarlett2_init_private(mixer, info);
 	if (err < 0)
 		return err;
 
+	/* Send proprietary USB initialisation sequence */
+	err = scarlett2_usb_init(mixer);
+	if (err < 0)
+		return err;
+
 	/* Read volume levels and controls from the interface */
 	err = scarlett2_read_configs(mixer);
 	if (err < 0)
@@ -2064,8 +3148,20 @@
 	if (err < 0)
 		return err;
 
-	/* Set up the interrupt polling if there are hardware buttons */
-	if (info->button_count) {
+	/* Create the MSD control */
+	err = scarlett2_add_msd_ctl(mixer);
+	if (err < 0)
+		return err;
+
+	/* Create the speaker switch control */
+	err = scarlett2_add_speaker_switch_ctl(mixer);
+	if (err < 0)
+		return err;
+
+	/* Set up the interrupt polling if there is a hardware volume
+	 * control
+	 */
+	if (info->line_out_hw_vol) {
 		err = scarlett2_mixer_status_create(mixer);
 		if (err < 0)
 			return err;
